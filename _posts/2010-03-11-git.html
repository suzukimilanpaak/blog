---
layout: post
title: Git入門 ゼロから始めるGitドリル
date: '2010-03-11T17:44:00.035Z'
author: Suzuki MilanPaak
tags:
- Git
modified_time: '2013-07-04T07:29:29.138+01:00'
thumbnail: http://3.bp.blogspot.com/_Sr-fE93PiOE/S6O_C0h-XRI/AAAAAAAAAHg/OsR0NdxSLT0/s72-c/branch_alone.png
blogger_id: tag:blogger.com,1999:blog-6758697817819098194.post-5855548907929864384
blogger_orig_url: http://engineerflies.blogspot.com/2010/03/git.html
---

gitの勉強をしつつ取ったノートを記事化しました。一応これを読めばざっくりとした導入やSVNとの違いが分かってもらえるように書いたつもりです。svnを使った経験があることを前提に進めていきます。<br /><br />svnの場合、一つのレポジトリに対して認証のあるユーザが変更を報告していくユースケースをとっています。gitの場合は、個々のローカルマシンにリポジトリが分散されて配置され、お互いに変更を報告しあうユースケース。これはLinuxの伝統的なバザール方式の開発を想定しています。そのため例えばカフェや電車で開発したり、マスターはgithubやgitfarm（<a href="http://git.wiki.kernel.org/index.php/GitHosting">Git Hosting</a>参照）にしておいて時々ローカルの変更を報告することも可能です。<br /><br /><br /><h1>目次</h1><br /><br /><ul><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#install">インストール</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#basic_manupilation">基本操作</a></li><ul><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#init">Gitリポジトリの作成</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#branch">ブランチの作成。</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#tag">タグ</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#ignore">ファイルを無視する</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#commit_index_workingtree">索引の理解</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#reset">取り消し</a></li><ul><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#summary">導入</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#hard_soft">--hardと--softの違い</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#checkout_single_file">一個のファイルの変更を取り消して最後のコミットの状態にする</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#reset_index">コミット前の変更を取り消す</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#reset_commit">間違ったコミットを無かったことにする</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#cancel_commit">間違ったコミットを無かったことにするが、ファイルへの変更を残す</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#revert">最後のコミットを取り消して指定したコミットの状態に戻す。そして、その取消しをコミットとして履歴に残す</a></li></ul></ul><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#collaboration">共同作業 - ２人</a></li><ul><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#stash">自分の変更を隠す</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#remote">リモートブランチ</a></li></ul><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#search_commit_from_log">履歴の検索</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#collab_two_root">共同作業 - 2人 + ルート</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#github">githubを使う</a></li><li><a href="http://draft.blogger.com/blogger.g?blogID=6758697817819098194#git_apache_basic_authentication">Git + Apache + Basic認証</a></li></ul><br /><br /><br /><br /><h1><a href="" name="install">インストール</a></h1><br />インストール方法はOSに応じて行ってください。<br /><a href="http://d.hatena.ne.jp/ttaka_tmp/20110412/1302585640">Mac</a><br /><a href="http://ubuntu-note.blog.so-net.ne.jp/2011-02-23">Ubuntu</a><br /><a href="https://help.github.com/articles/set-up-git#platform-windows">Windows</a><br /><br /><br /><h1><a href="" name="basic_manupilation">基本操作</a></h1><br /><br /><h2><a href="" name="init">Gitリポジトリの作成</a></h2><br /><pre class="prettyprint">$ mkdir ~/workspace/git<br />$ cd  ~/workspace/git<br /><br /># 初期化<br />$ git init<br />$ ls .git<br />branches  config  description  HEAD  hooks  info  objects  refs<br />$ echo trial &gt; test.txt<br /><br /># 索引の追加<br /># 索引はコミットする前のステージのようなもの。<br /># 索引はgit add　によって繰り返し更新可能<br /># git add .はカレントディレクトリ以下のディレクトリ／ファイルを再帰的にスナップショットに追加します<br />$ git add .<br /># 削除したファイルを索引に追加する場合は -uが必要。例, git add -u path/to/files/no/longer/necessary <br /><br /># メッセージを指定してコミット<br />$ git commit -m "initial commitment"<br /><br /># ブランチの一覧を表示<br />$ git branch<br />* master #=&gt; masterというブランチは初期状態で作成されます<br />$ git log<br />commit e1bf45812b9eedb8aa578af3c0e87a96d84cf3b6<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Fri Mar 12 00:28:59 2010 +0000<br /><br />initial commitment<br /><br /></sin></pre><br /><br />場所を移動してもgitは動作します。レポジトリは作業ディレクトリと同じ場所にあります。<br /><pre class="prettyprint">$ mkdir trial<br />$ mv test.txt trial/<br />$ mv .git trial/<br />$ cd trial<br /><br /># gitが動作している事を確認<br />$ git show #最後のコミット情報が表示される<br /></pre><br /><br />こまめにコミットすることは個人で開発を進めている時にも非常に有効です。subversionと大きく違うところは個人でリポジトリを所有しているところです。マスターになるリポジトリにpush(後述)しない限り未試験のコードをローカルのリポジトリにコミットすることができます。例えば、複数の実装方法を思いついたときに現在の内容を一時的なソース保管庫としてリポジトリにコミットしておいて、ある方法が失敗したと思ったらすぐ元の位置に戻ればよいわけです。<br /><br />こまめなコミットによってローカルのlogが汚れるのが嫌な場合は、tag（後述）を使用したり、公開用のリポジトリをもう一つ用意することによって対処できます。Gitを採用するのならこのアドバンテージを利用すべきでしょう。折角subversionから切り替えるのなら気持ちも一緒に切り替えると使い方の幅も広がるのではないでしょうか。<br /><br /><br /><h2><a href="" name="branch">ブランチの作成</a></h2><br /><a href="http://3.bp.blogspot.com/_Sr-fE93PiOE/S6O_C0h-XRI/AAAAAAAAAHg/OsR0NdxSLT0/s1600-h/branch_alone.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5450410029230218514" src="http://3.bp.blogspot.com/_Sr-fE93PiOE/S6O_C0h-XRI/AAAAAAAAAHg/OsR0NdxSLT0/s400/branch_alone.png" style="cursor: hand; cursor: pointer; height: 182px; width: 356px;" /></a><br /><br /><pre class="prettyprint">$ git branch new <br />$ git branch<br />*  master #=&gt; *は現在どのブランチを参照しているかを示しています<br />new<br /><br /># svnのcheckoutはリポジトリから最新を取得しますが、<br /># gitのcheckoutはブランチを切り替えてその最新を取得します。<br />$ git checkout new<br />Switched to branch 'new'<br />$ git branch<br />master<br />* new<br />$ git checkout master<br /><br /># ブランチの削除<br />$ git branch -d new<br /></pre><br /><br />ブランチの作成(2)<br /><pre class="prettyprint"># 新しくブランチを作成してチェックアウトします。= git branch new + git checkout new<br />$ git checkout -b new<br />$ echo ' of git' &gt;&gt; test.txt<br /><br /># 変更をリポジトリに報告<br />$ git add .<br /><br /># 索引と最後のコミットを比較<br />$ git diff --cached<br />diff --git a/test.txt b/test.txt<br />index 10b4e1b..48215e2 100644<br />--- a/test.txt<br />+++ b/test.txt<br />@@ -1 +1,2 @@<br />trial<br />+ of git<br /><br /># 今どんな状態？<br />$ git status<br /># On branch new # newブランチ上に<br /># Changes to be committed: # コミットすべき変更有り <br />#   (use "git reset HEAD <file>..." to unstage)<br />#<br /># modified:   test.txt #更新: test.txt<br />#<br />$ cat .git/COMMIT_EDITMSG <br />modified test.txt<br /># Please enter the commit message for your changes. Lines starting<br /># with '#' will be ignored, and an empty message aborts the commit.<br /># On branch new<br /># Changes to be committed:<br />#   (use "git reset HEAD <file>..." to unstage)<br />#<br /># modified:   test.txt<br />#<br /><br /># -mオプションを省略するとgit diffと同様に<br /># commitによってどのような変更がなされるか#付きのコメント行で示される。<br />$ git commit<br />modified test.txt<br /># On branch new <br /># Changes to be committed: <br />#   (use "git reset HEAD <file>..." to unstage) #unstage（索引を空に）したい場合はgit rest HEADしてね<br />#<br /># modified:   test.txt <br />#<br /></file></file></file></pre><br />svnのようにbranch用のディレクトリをこしらえる必要は無い。<br />gitではブランチを切り替えることで作業ディレクトリの状態を切り替えます。<br /><br />現在のブランチは.git/HEADで管理されています。<br /><pre class="prettyprint">$ cat .git/HEAD<br />ref: refs/heads/new<br />$ cat .git/refs/heads/new<br />bdfb3c51bba2c6d60e7bc326ea686702849c21ab<br />$ git show<br />commit bdfb3c51bba2c6d60e7bc326ea686702849c21ab<br />$ cat test.txt<br />trial<br />of git<br />$ git checkout master<br />$ cat .git/HEAD<br />ref: refs/heads/master<br />$ cat test.txt<br />trial<br /><br /># 作業ディレクトリにnewブランチの変更を引き込む<br />$ git pull . new<br />$ cat test.txt <br />trial<br />of git<br />$ gitk<br /></pre><br /><br /><br /><h2><a href="" name="tag">タグ</a></h2><br /><br /><pre class="prettyprint">$ git tag v0.10.00<br /><br /># タグの一覧表示<br />$ git tag -l<br />v0.10.00<br />vx.xx.xx<br />:<br />vx.xx.xx<br /># タグはいろんな箇所で使えます<br />$ git diff v0.10.00 ORIG_HEAD<br /># v0.10.0の位置に "stable" という名前の新しいブランチを作成<br />$ git branch stable v0.10.00 <br /></pre><br /><br /><br /><h2><a href="" name="ignore">ファイルを無視する</a></h2><br /><br /><pre class="prettyprint">$ mkdir bin<br />$ touch bin/gabage<br />$ git status<br /># On branch master<br /># Untracked files:<br />#   (use "git add <file>..." to include in what will be committed)<br />#<br /># bin/ =&gt; binが追跡されてないのでgit addして と言ってる<br />nothing added to commit but untracked files present (use "git add" to track)<br /><br />$ vi .gitignore<br />bin/*                                                                               */  <br />$ git status<br /># On branch master<br /># Untracked files:<br />#   (use "git add <file>..." to include in what will be committed)<br />#<br /># .gitignore =&gt; .gitignoreもgitの管理対象<br />nothing added to commit but untracked files present (use "git add" to track)<br /><br />$ git add .gitignore<br />$ git commit<br />Added new file .gitignore           <br />$ git status<br /># On branch master<br />nothing to commit (working directory clean)<br /></file></file></pre><br /><br /><br /><h2><a href="" name="commit_index_workingtree">索引の理解</a></h2><br />コミット - Gitでは履歴内にある１点のことを指す。プロジェクトの全履歴は 相互に関連したコミットの集合により表現されています。git では"コミット"という言葉を 他のリビジョン管理システムが使用する "リビジョン" または "バージョン"と同じ意味で 使用することがあります。また、コミットオブジェクト の略称として使われることもあります。<br /><br />索引 - コミットしたいものの追跡を保つ為、git は "索引(index)" と呼ばれる 特別なエリア内にツリーの中身のスナップショットを保管しています。<br /><br />コミット[HEAD]<br />↑<br />↑ git commit<br />↑<br />索引[index]<br />↑<br />↑ git add<br />↑<br />作業ディレクトリ[working tree]<br /><br /><pre class="prettyprint">$ echo 1 &gt; diff.txt<br />$ git add diff.txt<br />$ echo 2 &gt; diff.txt<br /><br /># 索引 と 最後のコミットを比較<br />$ git diff --cached<br />diff --git a/diff.txt b/diff.txt<br />new file mode 100644<br />index 0000000..d00491f<br />--- /dev/null<br />+++ b/diff.txt<br />@@ -0,0 +1 @@<br />+1<br /><br /># 作業ディレクトリ と 索引 を比較<br />$ git diff<br />diff --git a/diff.txt b/diff.txt<br />index d00491f..0cfbf08 100644<br />--- a/diff.txt<br />+++ b/diff.txt<br />@@ -1 +1 @@<br />-1<br />+2<br /><br /># 作業ディレクトリ と 最後のコミット を比較<br />$ git diff HEAD<br />diff --git a/diff.txt b/diff.txt<br />new file mode 100644<br />index 0000000..0cfbf08<br />--- /dev/null<br />+++ b/diff.txt<br />@@ -0,0 +1 @@<br />+2<br /></pre><br /><br /><br /><h2><a href="" name="reset">取り消し</a></h2><br /><br /><br /><h3><a href="" name="summary">導入</a></h3>一口に変更を元に戻すといってもシングルリポジトリなSVNと異なり以下にあげたようにいくつかの場面があります。これは索引やコミットそしてリモートなどの仕組み上の違いによるものです。<br /><br />- 一個のファイルの変更を取り消して最後のコミットの状態にする<br />git reset -- filename<br /><br />- 最後のコミットの内容に索引と作業ディレクトリを戻す<br />git reset --hard HEAD<br /><br />- 最後のコミットと索引と作業ディレクトリをその前のコミットに置き換える<br />git reset --hard ORIG_HEAD<br /><br />- 最後のコミットの後に、その前のコミットの状態をコミットする<br />git revert HEAD<br /><br />以下に違いを解説します。でもその前に --hardっていうオプションはなんなんでしょうか？--hardがあるなら--softもあるのか？<br /><br /><h3><a href="" name="hard_soft">--hardと--softの違い</a></h3><br /><pre class="prettyprint">$ git reset -h<br />--mixed reset HEAD and index                <br />--soft  reset only HEAD                     <br />--hard  reset HEAD, index and working tree　<br />--merge reset HEAD, index and working tree<br /></pre><br /><br /><h3><a href="" name="checkout_single_file">一個のファイルの変更を取り消して最後のコミットの状態にする</a></h3>きっと一番よく使うのがこれ。コミットしていない変更がある場合は単にgit checkout filenameとしてもファイルの内容は最後のコミットの状態には戻らない。git reset --hardは作業ディレクトリ以下を全て最後のコミットの状態に戻してしまう。そんな時は '--'オプションをつけると一個のファイルだけを戻すことができる。<br /><pre class="prettyprint">$ <b>git checkout -- filename</b><br /></pre><a href="http://norbauer.com/notebooks/code/notes/git-revert-reset-a-single-file">参考</a><br /><br /><br />このコマンドで削除したファイルをリポジトリから復活するもできます。<br /><pre class="prettyprint">$ git status<br /># On branch master<br /># Changed but not updated:<br />#   (use "git add/rm <file>..." to update what will be committed)<br />#   <b>(use "git checkout -- <file>..." to discard changes in working directory)</file></b><br />#<br /># deleted:    rerun.txt<br /><br />$ git checkout -- rerun.txt<br />$ ls<br />rerun.txt<br /></file></pre><br /><h3><a href="" name="reset_commit">間違ったコミットを無かったことにする</a></h3><br /><pre class="prettyprint">$ touch abigmistake<br />$ git add .<br />$ git commit -m 'a big mistake'<br />$ git log<br />commit b37c941bfe9364b681c8b760397b14e846b8fc7d<br />Author: suzukimilanpaak <sin .wave808="" gmail.com=""><br />Date:   Fri Mar 19 17:05:55 2010 +0000<br /><br />a big mistake<br /><br />commit bdfb3c51bba2c6d60e7bc326ea686702849c21ab<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Fri Mar 12 01:08:36 2010 +0000<br /><br />modified test.txt<br /><br />$ <b>git reset --hard ORIG_HEAD</b><br /><br /># 以下のように特定のタグを指定することもできる<br />$ git reset --hard v0.10.00<br /><br />#<b>注意！： 作業ディレクトリの変更も削除されてしまう</b><br />$ ls<br />bin test.txt<br /><br />$ git log<br />commit bdfb3c51bba2c6d60e7bc326ea686702849c21ab<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Fri Mar 12 01:08:36 2010 +0000<br /><br />modified test.txt<br /><br />commit e1bf45812b9eedb8aa578af3c0e87a96d84cf3b6<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Fri Mar 12 00:28:59 2010 +0000<br /><br />initial commitment<br /><br /></sin></sin></sin></sin></pre><br />注意! git reset --hard ORIG_HEADはリポジトリを直接変更します。誤ったコミットの履歴HEAD（この場合 'a big mistake'）を取り除きます。変更を取り消した履歴を残すことはありません。そのため他の作業者がそのコミットを既に取り寄せていた場合親族関係が崩れてしまい、他の作業者の変更がどこにも到達不可能になってしまうというケースが起こりうります。そのためgit reset --hard ORIG_HEADを行う場合は他の作業者に事前の確認が必要です。<br /><br /><h3><br /><a href='' name='cancel_commit'>間違ったコミットを無かったことにするが、ファイルへの変更をリセットしない</a></h3><br />$ git reset --soft HEAD^<br /><br />コミットに含んで欲しくない変更があった場合や、タイポを後で見つけてしまった場合、新たな変更をコミットに含みたい場合などに便利<br /><a href='http://stackoverflow.com/questions/927358/how-to-undo-the-last-git-commit'>参照</a><br /><br /><br /><h3><a href="" name="revert">最後のコミットを取り消して指定したコミットの状態に戻す。そして、その取消しをコミットとして履歴に残す</a></h3><br /><a href="http://3.bp.blogspot.com/_Sr-fE93PiOE/S6O-3zOiYgI/AAAAAAAAAHY/dkPHJCafWP4/s1600-h/bob+edited+then+alice+edited.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5450409839901696514" src="http://3.bp.blogspot.com/_Sr-fE93PiOE/S6O-3zOiYgI/AAAAAAAAAHY/dkPHJCafWP4/s400/bob+edited+then+alice+edited.png" style="cursor: hand; cursor: pointer; height: 205px; width: 400px;" /></a><br />他の作業者がすでに間違ったコミットを取り寄せ済みの場合、間違ったコミットの変更を取り消すコミットを上書きする方法が望ましいようです。単に git revertに間違ったコミットへの参照を渡すことによって変更を取り消す新しいコミットが作成されます。 また、新しいコミットに対するコミットメッセージが促されます。<br /><br /><pre class="prettyprint">$ echo foo &gt; test.txt<br />$ git commit -am 'Modified test.txt'<br /># HEADをORIG_HEADの内容に戻す。コミットも同時に行われます<br />$ <b>git revert HEAD</b><br /><br />Revert "Modified test.txt"<br /><br />This reverts commit 07abe15e79f4c1429fb1d22247723e29dc50293a.<br /><br /># Please enter the commit message for your changes. Lines starting<br /># with '#' will be ignored, and an empty message aborts the commit.<br /># On branch master<br /># Changes to be committed:<br />#   (use "git reset HEAD <file>..." to unstage)<br />#<br />#       modified:   test.txt<br />#<br /><br />$ git log<br />commit 42b30ec986d7fdb8d76c7a5b7c89f17114e8039c<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Fri Mar 12 01:45:28 2010 +0000<br /><br />Revert "Modified test.txt"<br /><br />This reverts commit 07abe15e79f4c1429fb1d22247723e29dc50293a.<br /><br />commit 07abe15e79f4c1429fb1d22247723e29dc50293a<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Fri Mar 12 01:45:04 2010 +0000<br /><br />Modified test.txt<br /><br />#ここまでの変更をGUIで表示<br />$ gitk &amp;<br /></sin></sin></file></pre><br /><br /><h3><a href="" name="reset_index">コミット前の変更を取り消す - git reset HEAD </a></h3><br />索引を空にする<br /><pre class="prettyprint">$ touch abigmistake<br />$ git add .<br />$ git status<br /># On branch master<br /># Changes to be committed:<br />#   (use "git reset HEAD <file>..." to unstage)　#unstageする場合はgit reset HEADしてね<br />#<br /># new file:   abigmistake<br />#<br />$ <b>git reset HEAD abigmistake</b><br /><br /># 索引から履歴は削除されるがファイル自体は残っている<br />$ ls<br />abigmistake  test.txt<br /><br /># もう一度索引に追加することもできます<br />$ git add abigmistake<br /><br />$ git reset --hard HEAD<br />$ ls<br />test.txt<br /></file></pre><br /><br /><h1><a href="" name="collaboration">共同作業 - ２人</a></h1><br /><a href="http://4.bp.blogspot.com/_Sr-fE93PiOE/S6O_HU_ZM6I/AAAAAAAAAHo/bM6_Y5IACVQ/s1600-h/revert_modified_text.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5450410106663023522" src="http://4.bp.blogspot.com/_Sr-fE93PiOE/S6O_HU_ZM6I/AAAAAAAAAHo/bM6_Y5IACVQ/s400/revert_modified_text.png" style="cursor: hand; cursor: pointer; height: 205px; width: 400px;" /></a><br /><br />準備<br /><pre class="prettyprint"># aliceの署名情報を設定<br />$ git config --global user.name "alice"<br />$ git config --global user.email "engineerflies+alice@gmail.com"<br />$ cat ~/.gitconfig<br />[user]<br />name = alice<br />email = engineerflies+alice@gmail.com<br />$ cd ..<br />$ mkdir alice &amp;&amp; mv trial alice<br />$ git clone ./alice bob<br />bob$ cd bob<br /># bobの署名情報を設定(この場合同じユーザで書名情報を設定しているので~/.configを上書きする)<br />bob$ git config --global user.name "bob"<br />bob$ git config --global user.email "engineerflies+bob@gmail.com"<br /><br />bob$ echo bob edited &gt;test.txt<br />bob$ git commit -am "bob edited"<br />alice$ echo alice edited &gt; test.txt<br />alice$ git add .<br /><br /># bobのmasterブランチを現在のaliceのmasterブランチに取り寄せる<br /># 変更情報のみがリモート追跡用ブランチに格納されます。test.txtは変更されない<br />alice$ git fetch ../bob master<br />alice$ cat test.txt <br />alice edited<br /><br /># aliceのHEADとbobからpullしたFETCH_HEADの差異を表示<br />alice$ git diff HEAD..FETCH_HEAD<br />diff --git a/test.txt b/test.txt<br />index 48215e2..4cba843 100644<br />--- a/test.txt<br />+++ b/test.txt<br />@@ -1,2 +1 @@<br />-trial<br />- of git<br />+bob edited<br />alice$ cat .git/FETCH_HEAD <br />b61671548ad431d9d865f0dd7eaeded68ec23711  branch 'master' of ../bob<br />alice$ git merge FETCH_HEAD<br />Updating 7d62c24..b616715<br />error: Entry 'test.txt' would be overwritten by merge. Cannot merge.<br /><br />#このコミットはコンフリクトを起こさない（HEADと作業ディレクトリを比較しているから？）<br />alice$ git commit -am "alice edited"<br />alice$ git log<br />commit d04f56226dde3ac67839a5695ab6fb5644a34bc9<br />Author: bob <engineerflies bob="" gmail.com=""><br />Date:   Thu Mar 18 13:21:13 2010 +0000<br /><br />alice edited<br /><br />commit 7d62c24953010a7628b29e891405e973b24a4239<br />Author: bob <engineerflies bob="" gmail.com=""><br />Date:   Fri Mar 12 01:44:29 2010 +0000<br /><br />ignore bin/<br />:<br />:<br /><br /># 再度merge - コンフリクトを起こします<br />alice$ git merge FETCH_HEAD<br />Auto-merging test.txt<br />CONFLICT (content): Merge conflict in test.txt<br />Automatic merge failed; fix conflicts and then commit the result.<br />このようにマージは常に直前にコミットが済んでいることを想定して行われる様です。<br />dirtyな状態（現在のブランチにコミットされていない変更が作業ディレクトリ内に含まれていること）ではマージは行われません。<br /><br />#コンフリクトを手動で回収します<br />alice$ vi test.txt<br />bob edited then alice edited<br /><br />結果の表示<br /># bobが最後にpullしてから、aliceがbobの変更をpullするまでの変更を表示する<br />$ gitk HEAD..FETCH_HEAD<br /># aliceとbobのそれぞれの変更のうちお互いに'到達不可能な'変更を表示する<br />$ gitk HEAD...FETCH_HEAD<br /><br />alice$ git commit -a<br />Merge branch 'master' of ../bob #マージ用のログを自動生成してくれます<br /><br />Conflicts: #コンフリクトが test.txtにあった<br />test.txt<br />#<br />#あなたはマージをコミットしている様です（とgitは認識しています）<br /># It looks like you may be committing a MERGE. <br />#これが正しくなかったら、.git/MERGE_HEADを削除してからもう一回トライしてね<br /># If this is not correct, please remove the file <br />#       .git/MERGE_HEAD<br /># and try again.<br />#<br /><br />#以下はいつもコミット時に表示されるメッセージと同じ<br /># Please enter the commit message for your changes. Lines starting<br /># with '#' will be ignored, and an empty message aborts the commit.<br /># On branch master<br /># Changes to be committed:<br />#   (use "git reset HEAD <file>..." to unstage)<br />#<br />#       modified:   test.txt<br />#<br /><br />#最後にaliceの変更をbobにも取り寄せておきます<br />#pull は fetch + mergeと等価です<br />bob$ git pull ../alice master<br /></file></engineerflies></engineerflies></pre><br /><br /><br /><h2><a href="" name="stash">自分の変更を隠す</a></h2><br /><pre class="prettyprint">bob$ echo love letter from canada &gt;&gt; testto.txt <br />bob$ git commit -am "love letter"<br />alice$ echo affair in us&gt;&gt;test.txt <br />alice$ git pull ../bob<br /># stash: 隠しもの<br />alice$ git stash save affair<br /># 隠しものを一覧する<br />alice$ git stash list<br />stash@{0}: On master: affair<br />alice$ git pull ../bob<br />alice$ vi test.txt <br />love letter from canada<br />love letter from us<br />alice$ git commit -am "in love"<br />alice$ git stash clear<br /></pre><br /><br /><br /><h2><a href="" name="remote">リモートブランチ</a></h2><br />今までの作業でaliceがgit pull ../bobした場合はbobをリモートとして登録することなくbobの変更をaliceにマージしていた。bobとaliceの共同作業が恒久的に行われる場合はリモートブランチとしてbobを登録してしまった方が便利だ。この方法によってリモートにあるブランチをローカルのブランチであるかの様にマージができます。<br /><pre class="prettyprint">bob$ echo bob edited &gt; test.txt <br />bob$ git commit -am "bob eidted"<br />alice$ git remote add bob ~/workspace/git/bob<br />alice$ git branch -r<br />bob/master<br />alice$ cat .git/config <br />[core]<br />repositoryformatversion = 0<br />filemode = true<br />bare = false<br />logallrefupdates = true<br />[remote "bob"]<br />url = /home/suzukimilanpaak/workspace/git/bob<br />fetch = +refs/heads/*:refs/remotes/bob/*                             <br /><br /><br /># 変更情報のみがリモート追跡用ブランチに格納されます。test.txtは変更されない */<br />alice$ git fetch bob<br /><br /># 自分のmasterとbobのmasterを比較<br /># -p はpatchの略、patch提出用のログメッセージを出力してくれます<br />alice$ git log -p master..bob/master<br />commit 460f2c8928b7f1b1065766c6c2652f79001a054c<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Thu Mar 18 14:01:11 2010 +0000<br /><br />bob eidted<br /><br /># -pによって出力される変更ログ<br />diff --git a/test.txt b/test.txt<br />index 843ad85..4cba843 100644<br />--- a/test.txt<br />+++ b/test.txt<br />@@ -1 +1 @@<br />-love letter from canada<br />+bob edited<br />alice$ git merge master bob/master<br />Already up-to-date with ed79b27cc53885e29b2770a9f20d8fb2174e48b6<br />Trying simple merge with 460f2c8928b7f1b1065766c6c2652f79001a054c<br />Simple merge did not work, trying automatic merge.<br />Auto-merging test.txt<br />ERROR: content conflict in test.txt <br />fatal: merge program failed<br />Automatic merge failed; fix conflicts and then commit the result.<br /><br /># コンフリクトを解消します<br />alice$ vi test.txt<br />love letter from canada<br />love letter from us<br />bob edited<br />alice$ git commit -a<br />Merge branch 'master'; commit 'bob/master'<br /><br />Conflicts:<br />test.txt<br /><br /># bobのリポジトリはaliceをcloneして作られたためoriginにaliceのリポジトリが指定されている。<br />bob$ cat .git/config <br />[core]<br />repositoryformatversion = 0<br />filemode = true<br />bare = false<br />logallrefupdates = true<br />[remote "origin"]<br />fetch = +refs/heads/*:refs/remotes/origin/*                                          */<br />url = /home/suzukimilanpaak/workspace/git/./alice<br />[branch "master"]<br />remote = origin<br />merge = refs/heads/master<br />bob$ git config -l<br />user.name=bob<br />user.email=sin.wave808+bob@gmail.com<br />core.repositoryformatversion=0<br />core.filemode=true<br />core.bare=false<br />core.logallrefupdates=true<br />remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*                             */<br />remote.origin.url=/home/suzukimilanpaak/workspace/git/./alice<br />branch.master.remote=origin<br />branch.master.merge=refs/heads/master<br />bob$ git branch -r<br />origin/HEAD -&gt; origin/master<br />origin/master<br />origin/new<br /><br /># git pullで引数を省略すると remote "origin"に登録されている変更を取り寄せる<br />bob$ git pull<br /><br /># ちゃんと変更されてる<br />bob$ cat test.txt <br />love letter from canada<br />love letter from us<br />bob edited<br /></sin></pre><br /><br /><br /><br /><h1><a href="" name="search_commit_from_log">履歴の検索</a></h1><br />履歴の検索に強くなっておくと今後の作業に便利です。<br /><br /><pre class="prettyprint">$ git log<br />commit 74f846a1bde25ef729b1742bfcd9fc693da1dbda<br /><br /># ある時点のコミットの詳細を表示<br /># SHA1値の全てを指定する必要は無い<br />$ git show 74f846a1bde25ef<br />commit 74f846a1bde25ef729b1742bfcd9fc693da1dbda<br />Merge: 17b2308 a01e7b7<br />Author: suzukimilanpaak <suzukimilanpaak none="" sanfrancisco.=""><br />Date:   Fri Mar 5 17:25:15 2010 +0000<br /><br />tip of collaboration<br /><br /><br />$ git show HEAD^  # HEAD の親を表示<br />$ git show HEAD^^ # HEAD の祖父を表示<br />$ git show HEAD~4 # HEAD の４つ前を表示<br /><br /># "love"を検索<br />$ git grep love<br />test.txt:love letter from canada<br />test.txt:love letter from us<br /><br /># "love"をタグv0.00.00から検索<br />$ git grep love v0.10.00 #=&gt; 何も見つからない<br />$ git log v0.10.00              # v0.10.00以降のコミット<br />$ git log --since=yesterday     # 昨日からのコミット<br />$ git log --since="3 hours ago" # 3時間前からのコミット<br /><br /># 最近２週間に "drivers" ディレクトリを修正したコミットでgitkで表示<br />$ gitk --since="2 weeks ago" drivers/ <br /><br /># ファイル名を指定<br />$ git diff v0.10.00:test.txt HEAD:test.txt<br /><br /># 変更したファイル名を検索<br />$ git log --stat|grep -A 5 haml<br />changed the view rendering engine html to haml.<br /><br />app/views/feeds/new.html.haml |   48 ++++++++++++++++------------------------<br />1 files changed, 19 insertions(+), 29 deletions(-)<br /></suzukimilanpaak></pre><br /><br /><br />差分の表示<br /><pre class="prettyprint">$ git checkout -b a<br />$ echo a &gt; a.txt<br />$ git commit -am "a"<br /><br /># aにあってmasterにないコミットを表示<br />$ git log master..a<br />commit b090846acd519c2066a8975ed4c76de700d66fc3<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Thu Mar 18 14:44:04 2010 +0000<br /><br />a<br /><br />#masterにあってaにないコミットを表示 =&gt; 何も表示されない<br />$ git log a..master<br /></sin></pre><br /><br /><br /><h1><a href="" name="collab_two_root">共同作業 - 2人 + ルート</a></h1><br />今まではbobがaliceをoriginとして参照する方法で行って来ました。実際の開発ではルートとなるレポジトリを設けてアリスとボブがそれを参照する方が管理を行いやすいです。<br /><br /><pre class="prettyprint">/opt$ mkdir git<br /><br /># rootというリポジトリをaliceからコピーして生成します。<br /># この作業の前にaliceが開発の先端になっているべきであることに注意してください。<br /># bare"裸の"とは作業ファイルがなく、管理情報だけを持つリポジトリという意味<br /># sharedを付けると共用のユーザ権限がリポジトリに与えられます<br />/opt$ git clone --bare --shared ~/workspace/git/alice/ root<br />alice$ git remote rm bob<br /><br /># -t: master ブランチをtrack"追跡"します<br />alice$ git remote add -t master origin /opt/git/root<br />alice$ git config -l<br />remote.origin.url=/opt/git/root<br />remote.origin.fetch=+refs/heads/master:refs/remotes/origin/master<br /># fetchがrefs/heads/masterを参照する様に設定されています<br /># -tオプションが指定されていない場合はrefs/heads/*が設定されます */<br /><br /># 引数なしでpullをするとremotes/origin/masterから変更を取り寄せます<br /># git remote add に-tを使用したためです。<br />alice$ git pull<br /><br /># これまでこの記事にそってリポジトリを作成してきた場合originはaliceを参照しているはずです<br />bob$ git config -l<br />remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*                                 */<br />remote.origin.url=/home/suzukimilanpaak/workspace/git/./alice<br />bob$ git remote rm origin<br />bob$ git remote add -t master origin /opt/git/root<br />bob$ git pull<br /><br /><br />bob$ echo love from vancouver &gt; test.txt<br />bob$ git commit -am "love from vancouver"<br />bob$ sudo git push origin master<br /><br />alice$ echo love from san francisco &gt; test.txt <br />alice$ git commit -am "love from san francisco"<br />alice$ sudo git push origin master<br />To /opt/git/root<br />! [rejected]        master -&gt; master (non-fast forward) <br />error: failed to push some refs to '/opt/git/root'<br /></pre><br /><br />fast forwardじゃないというメッセージがでてpushが拒絶されます。<br />fast forward - 今行おうとしているコミットが既に他方のコミットに含まれている場合、gitは現在のブランチの先頭をマージされるブランチの先頭の位置に進め、新しいコミットは作成されません。これをfast forwardといいます。<br /><br />この場合、aliceの変更はbobが先に行った変更と衝突するため拒絶されています。別の言い方をすると、共有リポジトリを置いて開発を行う場合fast forwardでない限りpushを受け付けてもらえないようです。<br /><br /><pre class="prettyprint">alice$ git pull<br />CONFLICT (content): Merge conflict in test.txt<br />alice$ vi test.txt<br />love from vancouver<br />love from san francisco<br />alice$ git commit -a<br />alice$ git push origin master<br /></pre><br />今度はpushを受け付けてもらえました<br /><br /><pre class="prettyprint">root$ git log<br />commit 40c4ded3df30d696a16552d928b3a46515cfb516<br />Merge: f180d66 a2bcc0d<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Thu Mar 18 17:00:51 2010 +0000<br /><br />Merge branch 'master' of /opt/git/root<br /><br />Conflicts:<br />test.txt<br /><br />commit f180d664d2943ccc83075e7dc1300f7dca999d72<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Thu Mar 18 16:40:37 2010 +0000<br /><br />love from san francisco<br /><br />commit a2bcc0d98f0e2c98d37df233aecb30caacb028f5<br />Author: bob <sin .wave808="" bob="" gmail.com=""><br />Date:   Thu Mar 18 16:39:49 2010 +0000<br /><br />love from vancouver<br /></sin></sin></sin></pre><br /><br /><br />- ３つ以上のマージ<br />http://www8.atwiki.jp/git_jp/pub/Documentation.ja/user-manual.html#merging-multiple-trees<br /><br /><h1><a href="" name="github">githubを使う</a></h1><br />githubをマスターレポジトリとしてそこにローカルの変更をpushする環境を構築しましょう。まずはgithubでユーザアカウントを作成してください。githubでレポジトリを作成するとリポジトリのURLを教えてくれるのでそれを今まで通りgit remoteで登録します。そしてgithubにsshの公開鍵を渡し、ローカルの変更がうまく反映されるまでの流れを説明します。<br /><br />- こちらにアクセスしてください。http://github.com/repositories/new<br />- 必要事項を書き込みます<br />- ローカル環境のセットアップの説明が表示されます<br /><br />説明ページの手順にそって作業を進めていきます。<br /><br /><pre class="prettyprint">$ cd ~/.ssh<br />既存の鍵ペアがある場合はバックアップをとります<br />$ mkdir key_backup<br />$ cp id_rsa* key_backup<br />$ rm id_rsa*<br />鍵ペアを生成します<br />$ ssh-keygen -t rsa -C "tekkub@gmail.com"<br /></pre><br />鍵のファイル名はレポジトリごとに指定するのが後々管理しやすいです。ここではid_rsa_githubを指定しました。<br /><br />ホスト毎にsshが読み込む秘密鍵が分かるように以下の設定を~/.ssh/configに書き込みます。<br /><pre class="prettyprint">$ vi config<br />Host github.com<br />HostName github.com<br />User git<br />IdentityFile /home/suzukimilanpaak/.ssh/id_rsa_github<br /></pre><br />接続可能か試します。Permission denied (publickey).が表示されず、パスフレーズを求められれば上記の設定が成功しているはずです。<br />ssh -v git@github.com<br /><br />公開鍵をコピーします。改行が入らないようにxclipを使用します<br /><pre class="prettyprint">$ sudo apt-get install xclip<br />$ cat ~/.ssh/id_rsa.pub | xclip -sel clip<br />xclipでクリップボードに公開鍵の内容が保存されているので、それを以下のページのKeyという項目に張り付けます<br />https://github.com/account#ssh_bucket<br />titleの項目は任意です。<br /><br />~/workspace/git$ git clone alice snippets<br />~/workspace/git$ cd snippets<br />リポジトリのアドレスは作成したリポジトリのページからコピーしてください<br />snippets$ git remote add -t master origin git@github.com:yourusername/code-snippets.git<br />snippets$ git pull<br /></pre><br /><br />READMEを作ってみましょう<br /><pre class="prettyprint">snippets$ vi README<br />This repo is for my private use only. thank you<br />何だかgithubの意に反したことを言っていますが。。。<br /><br />snippets$ git add .<br />snippets$ git commit -am "added README"<br />snippets$ git push origin master<br /></pre><br /><br />- Network Graphを覗いてみましょう。今までの変更がグラフィカルに表示されているはずです。<br />http://github.com/yourusername/code-snippets/network<br />すばらしい<br /><br />このセクションを読んだあとに山形浩生さんが公開されているEric Raymondの<a href="http://cruel.org/freeware/cathedral.html">伽藍とバザールの日本語訳</a>をご覧になられると良いかもしれません。このページの読者にはこれからオープンソースの開発に携わってみたいと思っている人も少なくないでしょう（私もその一人です）。githubの空気、ノリをつかむにはちょうど良い資材だと思います。<br /><br /><br /><h1><a href="" name="git_apache_basic_authentication">Git + Apache + Basic認証</a></h1><br />エンタープライズな開発の現場でもgitが使われるといいですね。Apacheと組み合わせて使う方法をご紹介します。svnと基本はあまり変わらないです。2009年末にapacheの連携を解消する<a href="http://progit.org/2010/03/04/smart-http.html">smart HTTP</a>が発表されました。Git &gt; v1.6.6、Apache 2.x という環境で恩恵をうけることができますが、下位互換がありますのでこの記事を書くに当たってそちらの構成を採用しました（これについては書き掛け）。<br /><br />Ubuntuでの設定をご説明します。まずはApacheが参照するリポジトリをDAV越しにローカルリポジトリが操作できるようにするところまで説明します。Smart HTTPについては後述します。<br /><br />認証方式について<br /><a href="http://d.hatena.ne.jp/thinca/20081108/1226155897">Gitは認証方式の指定ができません</a>。そしてBasic認証を行おうとします。<a href="http://github.com/rctay/git/commit/b8ac923010484908d8426cb8ded5ad7e8c21a7f6">http.authanyで全てのHTTP認証方式に対応できるよう</a>ですが都度で認証方式を決定するまでリトライするので重いようです。これではSmart HTTPを採用した意味がないので使用は避けた方がいいでしょう。<br /><br /><br /><pre class="prettyprint"># DocumentRootの場所を探します<br />$ grep -r DocumentRoot /etc/apache2/*                                               */<br /># DocumentRootに移動<br />$ cd /var/www<br />$ sudo mkdir dev.git<br /># 裸のgitリポジトリを作成します。apacheユーザでアクセスするので--sharedオプションは使用しません。<br />$ sudo git --bare init<br />$ git update-server-info<br /><br /># apacheユーザを検索（apacheが動作している前提）<br />$ ps aux |grep apache<br />www-data  1862  0.0  0.0  40064    52 ?        S    09:10   0:00 /usr/sbin/apache2 -k start<br />$ sudo chown -R www-data:www-data dev.git<br />$ cd /etc/apache2<br /></pre><br /><br />Ubuntuでapache2をapptitudeやapt-getからインストールした場合、/etc/apache2/mods-available/dav.loadがあるはずです。特に設定の変更は必要ありません。<br /><br />次に<a href="http://httpd.apache.org/docs/2.0/ja/mod/mod_dav_fs.html">DAVLockDBディレクティブ</a>があるか確認します。ms_dav_fsはユーザの操作をロックするためにSDBMを使用します。そのためこのディレクティブによってデータベースファイルが指定されている必要があります。<br /><pre class="prettyprint">$ grep -r DAVLockDB mods-available/*                                            */<br />mods-available/dav_fs.conf:DAVLockDB /var/lock/apache2/DAVLock<br />モジュールを有効にします。<br />$ sudo a2enmod dav dav_fs<br /></pre><br /><br />バーチャルホストの作成<br /><pre class="prettyprint">$ sudo vi sites-available/git<br />NameVirtualHost *<br />&lt;VirtualHost *&gt;<br />ServerName &lt;servername&gt;<br />ServerAdmin a.hi.tech.hippie@@googlemail.com<br />DocumentRoot /var/www/dev.git<br />ErrorLog /var/log/apache2/error.dev.git.log<br /><br />&lt;Location /&gt;<br />DAV on<br />AuthType Basic<br />AuthName 'developer'<br />AuthUserFile /etc/apache2/.htbasic<br />Require valid-user<br />&lt;/Location&gt;<br />&lt;/VirtualHost&gt;<br /><br />$ sudo vi /etc/hosts<br />127.0.0.1       &lt;servername&gt;<br />127.0.1.1       &lt;servername&gt;<br /><br />$ htpasswd -c /etc/apache2/.htbasic &lt;user&gt;<br />$ /etc/init.d/apache2 restart<br /></pre><br />ブラウザでhttp://&lt;servername&gt;/にアクセスして認証が通るか確認してください。失敗した場合はErrorLogディレクティブで指定したログファイルを参照しながら修正してください。<br /><br />gitがapacheにアクセスできるように ~/.netrcファイルに次の記述をして作成してください。~/netrcはオーナーだけが読み書きできるように権限に600を設定してください。<br /><pre class="init" name="code">machine &lt;servername&gt;<br />login &lt;user&gt;<br />password &lt;password&gt;<br /></pre><br /><br /><br />それではApache上のリポジトリからローカル作業用のcloneを作りましょう。<br /><pre class="prettyprint">~/workspace/git$ git clone http://&lt;servername&gt;/ dev<br /></pre><br /><br />もしこれが動作しない場合、curlを使って認証が通っているか確かめてみましょう。<br /><pre class="prettyprint">curl --netrc --location -v http://&lt;username&gt;@&lt;servername&gt;/HEAD<br /></pre><br /><br />初めてのプッシュ<br /><pre class="prettyprint">~/workspace/git/dev$ touch work?<br />~/workspace/git/dev$ git add .<br />~/workspace/git/dev$ git commit -m "created work?" <br /># masterブランチの内容をoriginにpush<br />~/workspace/git/dev$ git push origin master<br />Fetching remote heads...<br />refs/<br />refs/tags/<br />refs/heads/<br />updating 'refs/heads/master'<br />from 0000000000000000000000000000000000000000<br />to   bd4637936d5b8978b82ef06f8a8b6f75b716552f<br />sending 2 objects<br />done<br />Updating remote server info<br /></pre><br />うまくいかない場合はApacheのリポジトリの所有者やwriteの権限、それからgit update-server-infoを実施したか再チェックしてみてください。<br /><br />ここまででGit + Apache + Basic認証の設定は完了ですが、この構成で開発を続けていくときっとpushやfetchが遅いことに気づくと思います。それはGitがHTTP越しに動作するときにPackfile(Gitのストレージファイル)をまるごと転送しないといけないためです。Smart HTTPではupload-packとreceive-packというApache上で動くCGIを用意しており、それらがおあつらえのpackfileを作成し、一連のpostを行うようです。GETパラメータにSmart HTTPを実施するかどうかが渡されるため、対応していない場合単純に無視され旧バージョンの動作をします。この設定に関しては後日追記するつもりです。それまで<a href="http://progit.org/2010/03/04/smart-http.html">こちらの記事</a>を参考にしてください。<br /><br /><br />この文章で扱ってないこと<br />- ダンプ<br /><br />この文章は著者の理解が甘いため時々修正したり、書き足したりして縦に伸びていく予定です。ツッコミ、文の分かりづらいなどの指摘お待ちしております。<br /><br /><br />.
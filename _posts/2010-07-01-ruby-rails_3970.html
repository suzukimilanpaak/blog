---
layout: post
title: Rubyシングルトンパターンいろいろ + Railsでの使用例
date: '2010-06-30T19:28:00.003+01:00'
author: Suzuki MilanPaak
tags:
- Ruby/ Ruby on Rails
modified_time: '2010-06-30T19:32:51.486+01:00'
blogger_id: tag:blogger.com,1999:blog-6758697817819098194.post-3613923758859837971
blogger_orig_url: http://engineerflies.blogspot.com/2010/06/ruby-rails_3970.html
---

Rubyでのシングルトンの定義はいろいろあります。カウントアップを実現する例をいくつかの方法で書いてみました。<br /><br /><br />この記事を書くにあたって以下の記事を参考にしました。<br /><a href=http://rubyeyeforthejavaguy.blogspot.com/2007/04/singleton-classes-in-ruby.html>Singleton Classes in Ruby - RUBY EYE FOR JAVA GUY</a><br />ここで書かれているRubyのシングルトンクラスを定義するためのいくつかの前提知識は割愛しました。理解が甘いなと感じた場合は読んでみてください。<br /><br /><br /><h1>シングルトンいろいろ</h1><br /><br /><h2>シングルトンメソッドを利用する方法</h2><br /><br /><h3>クラス変数/メソッドを利用する方法</h3><br /><br /><pre class=ruby name=code><br />class MyCount<br />  @@count = 0;<br /><br />  def self.up<br />    @@count += 1<br />  end<br /><br />end<br /><br />puts MyCount.up #=> 1<br />puts MyCount.up #=> 2<br /></pre><br />シンプルにクラスに対してシングルトンメソッドを定義しています。別の言い方をするとClassクラスのインスタンスであるMyCountにシングルトンメソッドを定義しています。<br /><br /><br />クラスへの仕様追加は以下の方法でもできます。ただし、def MyCount.upからMyCountクラスのクラス変数を参照することができないのでMyCount.up内で定義しています。<br /><pre class=ruby name=code><br />class MyCount; end<br /><br />def MyCount.up<br />  @@count ||= 0<br />  @@count +=1<br />end<br /></pre><br /><br /><br /><br /><h2>シングルトンクラスを利用する方法</h2><br /><br /><h3>暗示的にシングルトンクラスを生成する</h3><br /><br /><pre class=ruby name=code><br />my_count = Object.new<br />def my_count.up<br />  @@count ||=0 <br />  @@count += 1<br />end<br /><br />puts my_count.up<br />puts my_count.up<br /></pre><br /><br />この例と先に挙げたdef self.upの例との違いは何でしょうか？self.upはクラスにupというシングルトンメソッドを定義しています。それに対してmy_count.upの場合、upがmy_countに対して定義されたとき新しく無名クラスがそのオブジェクトとクラスの間に挿入します。その無名クラスをシングルトンクラスと呼びます。これはあるオブジェクトに対して最初にメソッドが定義された時に起こります。<br /><br />my_count.upを呼ぶとき、インタープリタは定義を見つけるために最初に無名クラスを検索し、実装のためにクラスハイラーキーを探します。<br /><br /><br /><br />- 内部クラス<br />上記の例で起きていることがイメージできましたでしょうか？次の例を見るとシングルトンクラスがどこにいるか分かりやすくなると思います。<br /><br />こちらの例は機械猫さんのところから拝借しました。<br /><a href=http://d.hatena.ne.jp/kikaineko/20060302>[ruby][デザパタ]Rubyでデザパタ Singleton編 - 機械猫の日記</a><br /><br /><pre class=ruby name=code><br />class Object<br />  class MyCount<br />    @@count=0<br />    def up<br />      @@count+=1<br />    end<br />  end<br /><br />  @@ins = MyCount.new<br />  <br />  def count<br />    @@ins<br />  end<br />end<br /><br />puts count.up<br />puts count.up<br /></pre><br />Objectクラスに内部クラスMyCountが定義されています。@@insはObjectクラスのクラス変数なのでObjectクラス中で一意になります。MyCountが無名である場合を想像してください。厳密には違う場所に定義されます。シングルトンクラスはほぼ内部クラスと似たような振る舞いをしますが、変数のスコープなどに違いがあります。<br /><br /><br /><br /><h3>明示的にシングルトンクラスを生成する</h3><br /><br /><pre class=ruby name=code><br />my_count = Object.new<br /><br />class << my_count #=> シングルトンクラスを定義して、my_countのインスタンスに仕様を追加<br />  @@count = 0<br />  def up<br />    @@count +=1<br />  end<br />end<br /><br />puts my_count.up<br />puts my_count.up<br /></pre><br />class << my_countはmy_countとObjectの間のシングルトンクラスに明示的にアクセスできます。この場合upはシングルトンクラスに対するインスタンスメソッドとなり、my_countに対するシングルトンメソッドとなります。別の言い方をするとシングルトンクラスはシングルトンメソッドを格納するための入れ物になります。この記法はいくつかのシングルトンメソッドをまとめて定義するのに便利です。<br /><br /><br />インスタンスではなくクラス定義にシングルトンクラスを定義する場合<br /><pre class=ruby name=code><br />class MyCount<br />  class << self<br />    @@count = 0<br />    def up<br />      @@count += 1<br />    end<br />  end<br />end<br /><br />puts MyCount.up<br />puts MyCount.up<br /></pre><br />class << selfはself=MyCountに対してシングルトンクラスを定義し、仕様を追加しています。インスタンスにシングルトンクラスを定義する先ほどの例との違いはありません。なぜならRubyでは全てのクラスがオブジェクトだからです。Railsでは明示的にシングルトンクラスをクラス定義内に追加するこの方法が好まれているらしいです。<br /><br /><br /><br /><h3>Singletonモジュールを利用する方法</h3><br /><br />Singletonモジュールを使うとincludeしたクラス自体をシングルトンクラスにしてくれます。シングルトンメソッドで使用するインスタンス変数はinitializeに書けば参照することができます。newはprivateにされているためインスタンスは生成できません。ClassName.instanceでインスタンスを取得します。<br /><pre class=ruby name=code><br />require 'singleton'<br /><br />class MyCount<br /> include Singleton<br /> def up<br />  @count+=1<br /> end<br /> def initialize<br />  @count=0<br /> end<br />end<br /><br />a,b = MyCount.instance, MyCount.instance <br />puts a == b # => true<br /># a.new # NoMethodError - new is private …<br /></pre><br /><br />Singletonモジュールが何をしているのかは<a href=http://d.hatena.ne.jp/gom68/20090308/1236504000>Ruby で Singleton - うっかりプログラミング日誌</a>や<a href=http://apidock.com/ruby/Singleton>Singleton - apidock.com</a>を参考にされるとよく理解が進むと思います。<br /><br /><br /><br /><h2>シングルトンクラスを定義したクラスを継承した場合</h2><br /><br /><pre class=ruby name=code><br />class MyCount<br />  class << self<br />    @@count = 0<br />    def up<br />      @@count += 1<br />    end<br />  end<br />end<br /><br />MyCount.up  #=> 1<br /><br />class Guests < MyCount; end<br /><br />Guests.up   #=> 2<br /></pre><br />継承したクラスGuestsのupはMyCountで定義されたシングルトンクラスのupを参照するみたいです。シングルトンクラスはそのまま子クラスに渡されるんですね。<br /><br /><br /><br /><br /><h1>Railsでのシングルトンパターンの例</h1><br />こちらを参考にしました。<br /><a href=http://dalibornasevic.com/posts/9-ruby-singleton-pattern-again>Ruby Singleton Pattern Again - Dalibor Nasevic</a><br /><br /><br />シングルトンパターンのRubyでの良い例の一つは、RailsでのInflections クラスの実装でしょう。Railsの異なる場所で使用されている全ての屈折規則(inflection rule - 単語の変換を定義する規則)にグローバルアクセスを与えているのはシングルトンインスタンス（Inflections.instance）です。<br /><br />まずは呼び出し元のinflectルールの定義から見ていきましょう。<br /><br />$RAILS_ROOT/config/initializers/inflections.rb<br /><pre class=ruby name=code><br />ActiveSupport::Inflector.inflections do |inflect|<br />  inflect.plural /^(ox)$/i, '\1en'<br />  # inflect.singular /^(ox)en/i, '\1'<br />  # inflect.irregular 'person', 'people'<br />  # inflect.uncountable %w( fish sheep )<br />end<br /></pre><br />inflectionsというメソッドを屈折規則を定義したブロック付きで呼び出しています。<br /><br /><br />以下が、簡略化したActiveSupport::Inflectorの定義です。<br /><pre class=ruby name=code><br />module ActiveSupport<br />  module Inflector<br />    class Inflections<br />      def self.instance<br />        @__instance__ ||= new<br />      end<br /><br />      attr_reader :plurals, :singulars, :uncountables, :humans<br /><br />      def initialize<br />        @plurals, @singulars, @uncountables, @humans = [], [], [], []<br />      end<br /><br />      def plural(rule, replacement)<br />        @uncountables.delete(rule) if rule.is_a?(String)<br />        @uncountables.delete(replacement)<br />        @plurals.insert(0, [rule, replacement])<br />      end<br /><br />      def singular(rule, replacement); end<br />      def irregular(singular, plural); end<br />      def uncountable(*words); end<br />      def human(rule, replacement); end<br />      def clear(scope = :all); end<br />    end<br /><br />    # Yields a singleton instance of Inflector::Inflections <br />    # so you can specify additional inflector rules.<br />    def inflections<br />      if block_given?<br />        yield Inflections.instance<br />      else<br />        Inflections.instance<br />      end<br />    end<br /><br />    def pluralize(word)<br />      result = word.to_s.dup<br /><br />      if word.empty? || inflections.uncountables.include?(result.downcase)<br />        result<br />      else<br />        inflections.plurals.each { |(rule, replacement)| break if result.gsub!(rule, replacement) }<br />        result<br />      end<br />    end<br /><br />    def singularize(word); end<br />    def humanize(lower_case_and_underscored_word); end<br />    def titleize(word); end<br />    def tableize(class_name); end<br />    def classify(table_name); end<br />  end<br />end<br /></pre><br />ActiveSupport::Inflector.inflectionsは29行目のinflectionsメソッドを呼び出します。ブロックが定義されている場合は、シングルトンインスタンスであるInflections.instanceを引数にブロックを実行します。先ほどのブロック内をもう一度見てください。inflectを引数に取っています。Inflections.instanceが代入され、inflect.plural /^(ox)$/i, '\1en'が実行されます。<br /><br />inflectはInflector::Inflectionsのインスタンスです。Inflector::Inflectionsはインスタンス変数に屈折規則を格納した配列を保持しています。１４行目のpluralメソッドを参照してみましょう。Inflector::Inflectionsのインスタンス変数@pluralsに新しい屈折規則が追加されます。<br /><br />実際の変換はActiveSupport::Inflector.pluralizeで行います。43行目の行頭ではinflectionsを引数なしで呼び出しており、33行目のとおりInflector.instanceを返します。gsub!はマッチが無い場合nilを返します。マッチする規則が発見された場合は結果を返しbreakしています。<br /><br />Inflector.inflectionsメソッドは"単／複数規則を定義するとき"、"Inflector::Inflectionsのインスタンスを取得したいとき"の二通りの使われ方をしています。どこからも単／複数形の規則を追加できる、その定義が全ての呼び出しに反映されるというのがシングルトンを使う利点です。こんな風に適所、シングルトンパターンを使うタイミングを思いつくでしょうか？この”どこからも”というのがシングルトンパターンを使うべき時の"匂い"になるでしょう。<br /><br /><br />.